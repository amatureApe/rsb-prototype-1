{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/FinderInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Provides addresses of the live contracts implementing certain interfaces.\n * @dev Examples are the Oracle or Store interfaces.\n */\ninterface FinderInterface {\n    /**\n     * @notice Updates the address of the contract that implements `interfaceName`.\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\n     * @param implementationAddress address of the deployed contract that implements the interface.\n     */\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\n\n    /**\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\n     * @param interfaceName queried interface.\n     * @return implementationAddress address of the deployed contract that implements the interface.\n     */\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/OptimisticOracleV2Interface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./FinderInterface.sol\";\n\n/**\n * @title Financial contract facing Oracle interface.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract OptimisticOracleV2Interface {\n    event RequestPrice(\n        address indexed requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes ancillaryData,\n        address currency,\n        uint256 reward,\n        uint256 finalFee\n    );\n    event ProposePrice(\n        address indexed requester,\n        address indexed proposer,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes ancillaryData,\n        int256 proposedPrice,\n        uint256 expirationTimestamp,\n        address currency\n    );\n    event DisputePrice(\n        address indexed requester,\n        address indexed proposer,\n        address indexed disputer,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes ancillaryData,\n        int256 proposedPrice\n    );\n    event Settle(\n        address indexed requester,\n        address indexed proposer,\n        address indexed disputer,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes ancillaryData,\n        int256 price,\n        uint256 payout\n    );\n    // Struct representing the state of a price request.\n    enum State {\n        Invalid, // Never requested.\n        Requested, // Requested, no other actions taken.\n        Proposed, // Proposed, but not expired or disputed yet.\n        Expired, // Proposed, not disputed, past liveness.\n        Disputed, // Disputed, but no DVM price returned yet.\n        Resolved, // Disputed and DVM price is available.\n        Settled // Final price has been set in the contract (can get here from Expired or Resolved).\n    }\n\n    struct RequestSettings {\n        bool eventBased; // True if the request is set to be event-based.\n        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\n        bool callbackOnPriceProposed; // True if callbackOnPriceProposed callback is required.\n        bool callbackOnPriceDisputed; // True if callbackOnPriceDisputed callback is required.\n        bool callbackOnPriceSettled; // True if callbackOnPriceSettled callback is required.\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n        uint256 customLiveness; // Custom liveness value set by the requester.\n    }\n\n    // Struct representing a price request.\n    struct Request {\n        address proposer; // Address of the proposer.\n        address disputer; // Address of the disputer.\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\n        bool settled; // True if the request is settled.\n        RequestSettings requestSettings; // Custom settings associated with a request.\n        int256 proposedPrice; // Price that the proposer submitted.\n        int256 resolvedPrice; // Price resolved once the request is settled.\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n    }\n\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n    // to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n\n    function defaultLiveness() external view virtual returns (uint256);\n\n    function finder() external view virtual returns (FinderInterface);\n\n    function getCurrentTime() external view virtual returns (uint256);\n\n    // Note: this is required so that typechain generates a return value with named fields.\n    mapping(bytes32 => Request) public requests;\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n     * This can be changed with a subsequent call to setBond().\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Set the proposal bond associated with a price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param bond custom bond amount to set.\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n     * changed again with a subsequent call to setBond().\n     */\n    function setBond(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 bond\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\n     * bond, so there is still profit to be made even if the reward is refunded.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function setRefundOnDispute(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual;\n\n    /**\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n     * being auto-resolved.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param customLiveness new custom liveness.\n     */\n    function setCustomLiveness(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 customLiveness\n    ) external virtual;\n\n    /**\n     * @notice Sets the request to be an \"event-based\" request.\n     * @dev Calling this method has a few impacts on the request:\n     *\n     * 1. The timestamp at which the request is evaluated is the time of the proposal, not the timestamp associated\n     *    with the request.\n     *\n     * 2. The proposer cannot propose the \"too early\" value (TOO_EARLY_RESPONSE). This is to ensure that a proposer who\n     *    prematurely proposes a response loses their bond.\n     *\n     * 3. RefundoOnDispute is automatically set, meaning disputes trigger the reward to be automatically refunded to\n     *    the requesting contract.\n     *\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function setEventBased(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual;\n\n    /**\n     * @notice Sets which callbacks should be enabled for the request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param callbackOnPriceProposed whether to enable the callback onPriceProposed.\n     * @param callbackOnPriceDisputed whether to enable the callback onPriceDisputed.\n     * @param callbackOnPriceSettled whether to enable the callback onPriceSettled.\n     */\n    function setCallbacks(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        bool callbackOnPriceProposed,\n        bool callbackOnPriceDisputed,\n        bool callbackOnPriceSettled\n    ) external virtual;\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param proposer address to set as the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address proposer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value for an existing price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was value (the proposal was incorrect).\n     */\n    function disputePriceFor(\n        address disputer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price value for an existing price request with an active proposal.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n     * hasn't been settled.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return resolved price.\n     */\n    function settleAndGetPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (int256);\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     */\n    function settle(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (uint256 payout);\n\n    /**\n     * @notice Gets the current data structure containing all information about a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the Request data structure.\n     */\n    function getRequest(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (Request memory);\n\n    /**\n     * @notice Returns the state of a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the State enum value.\n     */\n    function getState(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (State);\n\n    /**\n     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return true if price has resolved or settled, false otherwise.\n     */\n    function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (bool);\n\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\n        public\n        view\n        virtual\n        returns (bytes memory);\n}\n"
    },
    "contracts/OO_BetHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@uma/core/contracts/oracle/interfaces/OptimisticOracleV2Interface.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract OO_BetHandler is ReentrancyGuard {\n    // Create an Optimistic oracle instance at the deployed address on Görli.\n    OptimisticOracleV2Interface oo =\n        OptimisticOracleV2Interface(0xA5B9d8a0B0Fa04Ba71BDD68069661ED5C0848884);\n\n    uint256 requestTime = 0; // Store the request time so we can re-use it later.\n    bytes32 constant IDENTIFIER = bytes32(\"YES_OR_NO_QUERY\"); // Use the yes no idetifier to ask arbitary questions, such as the weather on a particular day.\n    address constant ZERO_ADDRESS = address(0);\n    // 0x0000000000000000000000000000000000000000\n\n    struct Bet {\n        uint256 betId;\n        bytes question;\n        uint256 expiry;\n        IERC20 bondCurrency;\n        address creator;\n        bool privateBet;\n        uint256 liveness;\n        uint256 reward;\n        bytes imgUrl;\n        BetStatus betStatus;\n    }\n\n    struct BetAmount {\n        uint256 betId;\n        address affirmation; // Address of the side of the bet that affirms the question.\n        IERC20 affirmationToken;\n        uint256 affirmationAmount; // Amount deposited into the bet by the affrimation.\n        address negation; // Address of the side of the bet that negates the question.\n        IERC20 negationToken;\n        uint256 negationAmount; // Amount deposited into the bet by the negation.\n    }\n\n    enum BetStatus {\n        LOADING,\n        OPEN,\n        ACTIVE,\n        SETTLING,\n        SETTLED,\n        CLAIMED,\n        DEAD\n    }\n\n    // ******** EVENTS ************\n\n    event BetSet(\n        address indexed creator,\n        uint256 indexed betId,\n        bytes indexed ancillaryData\n    );\n\n    event BetTaken(address indexed taker, uint256 indexed betId);\n\n    event DataRequested(\n        address indexed affirmation,\n        address indexed negation,\n        uint256 indexed betId\n    );\n\n    event BetSettled(\n        address indexed affirmation,\n        address indexed negation,\n        uint256 indexed betId\n    );\n\n    event WinningsClaimed(\n        uint256 indexed betId,\n        uint256 indexed totalWinnings,\n        int256 indexed winner\n    );\n\n    event BetCanceled(\n        uint256 indexed betId,\n        address indexed bondCurrency,\n        uint256 indexed refundAmount\n    );\n\n    event BetKilled(\n        uint256 indexed betId,\n        uint256 indexed affirmationRefund,\n        uint256 indexed negationRefund\n    );\n\n    uint256 public betId = 0; // latest global betId for all managed bets.\n    mapping(uint256 => Bet) public bets; // All bets mapped by their betId\n    mapping(bytes => uint256) public hashIds; // A hash of bet question, msg.sender, and timestamp to betId\n    mapping(uint256 => BetAmount) public betAmounts; // All bet amounts mapped by their betId.\n    mapping(address => uint256[]) public userBets; // All bets the user is and has participated in.\n\n    // ********* MUTATIVE FUNCTIONS *************\n\n    function setBet(\n        bytes calldata _question,\n        uint256 _expiry,\n        IERC20 _bondCurrency,\n        uint256 _liveness,\n        uint256 _reward,\n        bool _privateBet,\n        bytes calldata _imgUrl\n    ) public nonReentrant {\n        Bet memory bet = Bet(\n            betId,\n            _question,\n            _expiry,\n            _bondCurrency,\n            msg.sender,\n            _privateBet,\n            _liveness,\n            _reward,\n            _imgUrl,\n            BetStatus.LOADING\n        );\n\n        bytes memory hashId = abi.encode(\n            _question,\n            msg.sender,\n            block.timestamp\n        );\n\n        emit BetSet(msg.sender, betId, _question);\n\n        bets[betId] = bet;\n        hashIds[hashId] = betId;\n        userBets[msg.sender].push(betId);\n        betId += 1;\n    }\n\n    function loadBet(\n        uint256 _betId,\n        address _affirmation,\n        IERC20 _affirmationToken,\n        uint256 _affirmationAmount,\n        address _negation,\n        IERC20 _negationToken,\n        uint256 _negationAmount\n    ) public nonReentrant {\n        Bet storage bet = bets[_betId];\n        require(msg.sender == bet.creator, \"not creator\");\n        require(\n            bet.creator == _affirmation || bet.creator == _negation,\n            \"must be participant\"\n        );\n        require(_affirmation != _negation, \"must have 2 parties\");\n        require(bet.betStatus == BetStatus.LOADING, \"not loading\");\n\n        BetAmount memory betAmount = BetAmount(\n            _betId,\n            _affirmation,\n            _affirmationToken,\n            _affirmationAmount,\n            _negation,\n            _negationToken,\n            _negationAmount\n        );\n\n        // Make sure to approve this contract to spend your ERC20 externally first\n        if (msg.sender == _affirmation) {\n            _affirmationToken.transferFrom(\n                msg.sender,\n                address(this),\n                _affirmationAmount\n            );\n        } else if (msg.sender == _negation) {\n            _negationToken.transferFrom(\n                msg.sender,\n                address(this),\n                _negationAmount\n            );\n        }\n\n        betAmounts[_betId] = betAmount;\n        bet.betStatus = BetStatus.OPEN;\n    }\n\n    function takeBet(uint256 _betId) public nonReentrant {\n        Bet storage bet = bets[_betId];\n        BetAmount storage betAmount = betAmounts[_betId];\n        require(msg.sender != bet.creator, \"Can't take your own bet\");\n        if (bet.privateBet == false) {\n            require(\n                betAmount.affirmation == ZERO_ADDRESS ||\n                    betAmount.negation == ZERO_ADDRESS,\n                \"Bet already taken\"\n            );\n        } else {\n            require(\n                msg.sender == betAmount.affirmation ||\n                    msg.sender == betAmount.negation,\n                \"Not bet recipient\"\n            );\n        }\n        require(bet.betStatus == BetStatus.OPEN, \"not Open\");\n\n        if (betAmount.affirmation == ZERO_ADDRESS) {\n            // Make sure to approve this contract to spend your ERC20 externally first\n            bet.bondCurrency.transferFrom(\n                msg.sender,\n                address(this),\n                betAmount.affirmationAmount\n            );\n            betAmount.affirmation = msg.sender;\n        } else {\n            // Make sure to approve this contract to spend your ERC20 externally first\n            bet.bondCurrency.transferFrom(\n                msg.sender,\n                address(this),\n                betAmount.negationAmount\n            );\n            betAmount.negation = msg.sender;\n        }\n\n        userBets[msg.sender].push(_betId);\n        bet.betStatus = BetStatus.ACTIVE;\n\n        emit BetTaken(msg.sender, _betId);\n    }\n\n    function requestData(uint256 _betId) public {\n        Bet storage bet = bets[_betId];\n        BetAmount storage betAmount = betAmounts[_betId];\n        require(\n            bet.betStatus == BetStatus.ACTIVE,\n            \"Bet not ready to be settled\"\n        );\n        require(\n            betAmount.affirmation == msg.sender ||\n                betAmount.negation == msg.sender\n        );\n\n        bytes memory ancillaryData = bet.question; // Question to ask the UMA Oracle.\n\n        requestTime = block.timestamp; // Set the request time to the current block time.\n        IERC20 bondCurrency = IERC20(bet.bondCurrency); // Use preferred token as the bond currency.\n        uint256 reward = bet.reward; // Set the reward amount for UMA Oracle.\n\n        // Set liveness for request disputes measured in seconds. Recommended time is at least 7200 (2 hours).\n        // Users should increase liveness time depending on various factors such as amount of funds being handled\n        // and risk of malicious acts.\n        uint256 liveness = bet.liveness;\n\n        // Now, make the price request to the Optimistic oracle with preferred inputs.\n        oo.requestPrice(\n            IDENTIFIER,\n            requestTime,\n            ancillaryData,\n            bondCurrency,\n            reward\n        );\n        oo.setCustomLiveness(IDENTIFIER, requestTime, ancillaryData, liveness);\n\n        bet.betStatus = BetStatus.SETTLING;\n        emit DataRequested(\n            betAmount.affirmation,\n            betAmount.negation,\n            betAmount.betId\n        );\n    }\n\n    // Settle the request once it's gone through the liveness period of 30 seconds. This acts the finalize the voted on price.\n    // In a real world use of the Optimistic Oracle this should be longer to give time to disputers to catch bat price proposals.\n    function settleRequest(uint256 _betId) public {\n        Bet storage bet = bets[_betId];\n        BetAmount storage betAmount = betAmounts[_betId];\n        require(bet.betStatus == BetStatus.SETTLING, \"Bet not settling\");\n        require(\n            betAmount.affirmation == msg.sender ||\n                betAmount.negation == msg.sender\n        );\n\n        bytes memory ancillaryData = bet.question;\n\n        oo.settle(address(this), IDENTIFIER, requestTime, ancillaryData);\n        bet.betStatus = BetStatus.SETTLED;\n\n        emit BetSettled(\n            betAmount.affirmation,\n            betAmount.negation,\n            betAmount.betId\n        );\n    }\n\n    function claimWinnings(uint256 _betId) public nonReentrant {\n        Bet storage bet = bets[_betId];\n        BetAmount storage betAmount = betAmounts[_betId];\n        uint256 totalWinnings = betAmount.affirmationAmount +\n            betAmount.negationAmount;\n        int256 settlementData = getSettledData(_betId);\n        require(bet.betStatus == BetStatus.SETTLED, \"Bet not yet settled\");\n        require(\n            msg.sender == betAmount.affirmation ||\n                msg.sender == betAmount.negation,\n            \"This is not your bet\"\n        );\n        require(\n            settlementData == 1e18 || settlementData == 0,\n            \"Invalid settlement\"\n        );\n        if (settlementData == 1e18) {\n            require(\n                msg.sender == betAmount.affirmation,\n                \"Negation did not win bet\"\n            );\n            bet.bondCurrency.transfer(betAmount.affirmation, totalWinnings);\n        } else {\n            require(\n                msg.sender == betAmount.negation,\n                \"Affirmation did not win bet\"\n            );\n            bet.bondCurrency.transfer(betAmount.negation, totalWinnings);\n        }\n\n        bet.betStatus = BetStatus.CLAIMED;\n\n        emit WinningsClaimed(bet.betId, totalWinnings, settlementData);\n    }\n\n    function cancelBet(uint256 _betId) public nonReentrant {\n        Bet storage bet = bets[_betId];\n        BetAmount storage betAmount = betAmounts[_betId];\n        uint256 refundAmount;\n        require(\n            bet.betStatus == BetStatus.LOADING ||\n                bet.betStatus == BetStatus.OPEN,\n            \"Bet already active\"\n        );\n        require(msg.sender == bet.creator, \"Not bet creator\");\n\n        if (bet.creator == betAmount.affirmation) {\n            refundAmount = betAmount.affirmationAmount;\n        } else {\n            refundAmount = betAmount.negationAmount;\n        }\n\n        bet.bondCurrency.transfer(bet.creator, refundAmount);\n\n        emit BetCanceled(bet.betId, address(bet.bondCurrency), refundAmount);\n    }\n\n    function killBet(uint256 _betId) public nonReentrant {\n        Bet storage bet = bets[_betId];\n        BetAmount storage betAmount = betAmounts[_betId];\n        int256 settlementData = getSettledData(_betId);\n        require(bet.betStatus == BetStatus.SETTLED, \"Bet not yet settled\");\n        require(\n            msg.sender == betAmount.affirmation ||\n                msg.sender == betAmount.negation,\n            \"This is not your bet\"\n        );\n        require(settlementData == 2 * 1e18, \"Bet is settleable\");\n        bet.bondCurrency.transfer(\n            betAmount.affirmation,\n            betAmount.affirmationAmount\n        );\n        bet.bondCurrency.transfer(betAmount.negation, betAmount.negationAmount);\n\n        bet.betStatus = BetStatus.DEAD;\n\n        emit BetKilled(\n            betAmount.betId,\n            betAmount.affirmationAmount,\n            betAmount.negationAmount\n        );\n    }\n\n    //******* VIEW FUNCTIONS ***********\n    function createQuestion(string memory _question)\n        public\n        pure\n        returns (bytes memory)\n    {\n        bytes memory question = bytes(\n            string.concat(\n                \"Q: \",\n                _question,\n                \"? --- A:1 for yes. 0 for no. 2 for ambiguous/unknowable\"\n            )\n        );\n        return question;\n    }\n\n    // Fetch the resolved price from the Optimistic Oracle that was settled.\n    function getSettledData(uint256 _betId) public view returns (int256) {\n        Bet storage bet = bets[_betId];\n        BetAmount storage betAmount = betAmounts[_betId];\n        require(\n            betAmount.affirmation == msg.sender ||\n                betAmount.negation == msg.sender\n        );\n\n        return\n            oo\n                .getRequest(\n                    address(this),\n                    IDENTIFIER,\n                    requestTime,\n                    bet.question\n                )\n                .resolvedPrice;\n    }\n\n    function getHashId(bytes calldata _question, uint256 timestamp)\n        public\n        view\n        returns (bytes memory)\n    {\n        return abi.encode(_question, msg.sender, timestamp);\n    }\n\n    function stringEncode(string calldata _string)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return bytes(_string);\n    }\n\n    function stringDecode(bytes calldata _bytes)\n        public\n        pure\n        returns (string memory)\n    {\n        return string(_bytes);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}